#lx:private;

const floatHint = Snippet->floatHint;

const __STATUS_NONE = 0;
const __STATUS_FOLLOW = 1;
const __STATUS_ACTIVE = 2;

let __status = __STATUS_NONE;
let __locusName = '';
let __text = [
/*0*/'<b>Рабочий:</b> в любой момент своего хода изменяйте результат кубика на +1 или -1. Важно: 6 + 1 даст 1, 1 - 1 даст 6.',
/*1*/'<b>Серебряный самородок:</b> за два самородка можно купить жетон в центральном хранилище.',
/*2*/'<b>Фишка игрока:</b> показывают текущее количество заработанных очков.',
/*3*/'<b>Фишка игрока:</b> показывают в каком порядке игроки ходят в течение раунда - чем правее (или выше) фишка, тем раньше.',
/*4*/'<b>Общий кубик:</b> в начале раунда разыгрывает в какое пронумерованное хранилище отправится товар.',
/*5*/'<b>Кубик игрока:</b> с его помощью берите жетоны с общего поля, добавляйте жетоны в свою вотчину, продавайте товары, или обменяйте кубик на двух рабочих.',
/*6*/'<b>Товары стадии:</b> будут открыты в свою стадию.',
/*7*/'<b>Товар раунда:</b> будет разыгран кубиком (отправится в пронумерованное хранилище) в начале своего раунда.',
/*8*/'<b>Товар в хранилище:</b> может быть забран игроком при введении в вотчину корабля.',
/*9*/'<b>Товар у игрока:</b> может быть продан, каждый даст по два победных очка. Проданная группа товаров даст серебряный самородок.',
/*10*/'<b>Товар проданный:</b> может дать очки только при наличии подходящих знаний.',
/*11*/'<b>Корабль:</b> позволит забрать товары из любого хранилища в вашу вотчину и сместит вашу фишку вправо по треку очередности хода.',
/*12*/'<b>Животные:</b> дает #?# победных очка. При наличии на пастбище животных этого же типа, они повторно приносят очки.',
/*13*/'<b>Замок:</b> дает немедленное дополнительное действие.',
/*14*/'<b>Рудник:</b> в конце каждой фазы приносит серебряный самородок.',

/*15*/'<b>Рынок:</b> позволит немедленно забрать корабль или животное с любого пронумерованного хранилища.',
/*16*/'<b>Церковь:</b> позволит немедленно забрать рудник, замок или знание с любого пронумерованного хранилища.',
/*17*/'<b>Гостиница:</b> даст четырех рабочих.',
/*18*/'<b>Мастерская:</b> позволит немедленно забрать постройку с любого пронумерованного хранилища.',
/*19*/'<b>Банк:</b> даст два серебряных самородка.',
/*20*/'<b>Ратуша:</b> позволит игроку добавить со своего планшета в вотчину любой шестиугольный жетон.',
/*21*/'<b>Склад:</b> позволит немедленно продать один любой тип товаров.',
/*22*/'<b>Сторожевая башня:</b> даст 4 победных очка.',

/*23*/'<b>Жетон бонуса:</b> чтобы получить бонус, заполните в своей вотчине все ячейки соответствующего цвета первым.',
/*24*/'<b>Жетон бонуса:</b> бонус тому, кто заполнит в своей вотчине все ячейки соответствующего цвета вторым.',

/*25*/'<b>Знание:</b> позволяет игнорировать правило о том, что в одном городе не может быть больше 1 здания одного типа.',
/*26*/'<b>Знание:</b> в конце фазы каждый рудник дает помимо самородка еще одного рабочего.',
/*27*/'<b>Знание:</b> продажа товаров даст не один, а два серебряных самородка.',
/*28*/'<b>Знание:</b> продажа товаров даст помимо самородка еще одного рабочего.',
/*29*/'<b>Знание:</b> при добавлении в вотчину корабля можно забрать товары из двух СОСЕДНИХ пронумерованных хранилищ.',
/*30*/'<b>Знание:</b> позволяет покупать за серебро жетоны из пронумерованных хранилищ.',
/*31*/'<b>Знание:</b> при добавлении в вотчину жетона животных дает на 1 победное очко больше за каждый жетон животного этого типа на пастбище.',
/*32*/'<b>Знание:</b> позволяет изменять результат кубика на +2, -2 за потраченного рабочего.',
/*33*/'<b>Знание:</b> при добавлении в вотчину здания, значение кубика считается +1, -1, как если бы был потрачен рабочий.',
/*34*/'<b>Знание:</b> при добавлении в вотчину лодки или животного, значение кубика считается +1, -1, как если бы был потрачен рабочий.',
/*35*/'<b>Знание:</b> при добавлении в вотчину рудника, знания или замка, значение кубика считается +1, -1, как если бы был потрачен рабочий.',
/*36*/'<b>Знание:</b> при взятии жетона из пронумерованного хранилища, значение кубика считается +1, -1, как если бы был потрачен рабочий.',
/*37*/'<b>Знание:</b> позволяет обменивать кубик на серебряный слиток (в дополнение к двум рабочим).',
/*38*/'<b>Знание:</b> позволяет обменивать кубик на четырех рабочих.',
/*39*/'<b>Знание:</b> в конце игры принесет по 3 победных очка за каждый тип проданных товаров.',
/*40*/'<b>Знание:</b> в конце игры принесет по 4 победных очка за каждый построенный склад.',
/*41*/'<b>Знание:</b> в конце игры принесет по 4 победных очка за каждую построенную сторожевую башню.',
/*42*/'<b>Знание:</b> в конце игры принесет по 4 победных очка за каждую построенную мастерскую.',
/*43*/'<b>Знание:</b> в конце игры принесет по 4 победных очка за каждую построенную церковь.',
/*44*/'<b>Знание:</b> в конце игры принесет по 4 победных очка за каждый построенный рынок.',
/*45*/'<b>Знание:</b> в конце игры принесет по 4 победных очка за каждую построенную гостиницу.',
/*46*/'<b>Знание:</b> в конце игры принесет по 4 победных очка за каждый построенный банк.',
/*47*/'<b>Знание:</b> в конце игры принесет по 4 победных очка за каждую построенную ратушу.',
/*48*/'<b>Знание:</b> в конце игры принесет по 4 победных очка за каждый тип животных, размещенный на пастбищах.',
/*49*/'<b>Знание:</b> в конце игры принесет 1 победное очко за каждый проданный жетон товара.',
/*50*/'<b>Знание:</b> в конце игры принесет по 2 победных очка за каждый жетон бонуса.'
];

let __timer = new lx.Timer(1000);
__timer.on = function(chip, event) {
	this.chip = chip;
	this.x = event.clientX;
	this.y = event.clientY;
	this.start();
};
__timer.whileCycle(function() {
	if (this.periodEnds()) {
		if (__locusName == this.chip.locus.name)
			__start(this.chip, this.x, this.y);
		else __finish();
		this.stop();
	}
});

Plugin->canvas.on('mousemove', function(event) {
	var staff = cofb.world.getIntersectedStaff();

	if (!staff || staff.locus === undefined) {
		__finish();
		return;
	}

	__follow(staff, event);
});

function __follow(chip, event) {
	if ( chip.info === undefined && chip.value === undefined ) {
		__finish();
		return;
	}

	if (__status == __STATUS_ACTIVE) {
		if (__locusName == chip.locus.name) {
			__locate( event.clientX, event.clientY );
			return;
		} else __finish();
	}

	__locusName = chip.locus.name;
	if (__status == __STATUS_FOLLOW) return;
	
	if (__status == __STATUS_NONE) {
		__status = __STATUS_FOLLOW;
		__timer.on(chip, event);
	}
}

function __start(chip, x, y) {
	__status = __STATUS_ACTIVE;

	var index = __textIndex(chip),
		text = __text[index];
	if ( index == 12 ) {
		var arr = text.split('#');
		arr[1] = 2 + ( chip.info.variant - 29 ) % 3;
		text = arr.join('');
	}

	floatHint->val.width('400px');
	floatHint->val.text(text);

	floatHint.width(floatHint->val.width('px') + 20 + 'px');
	floatHint.height(floatHint->val->text.height('px') + 20 + 'px');

	__locate(x, y);
	floatHint.show();
}

function __finish() {
	__status = __STATUS_NONE;
	__locusName = '';
	floatHint.hide();
}

function __textIndex(chip) {
	if ( chip.locus.name.substr(0, 5) == 'point' ) return 2;
	if ( chip.locus.name.substr(0, 3) == 'seq' ) return 3;

	if ( chip.value != undefined ) {
		if ( chip.locus.parent === bgGame.field ) return 4;
		return 5;
	}

	if ( chip.info.groupe == GROUPE_GOODS ) {
		if ( chip.locus.name.substr(0, 2) == 'st' ) return 6;
		if ( chip.locus.name.substr(0, 2) == 'tn' ) return 7;
		if ( chip.locus.parent === bgGame.field ) return 8;
		if ( chip.locus.name == 'goods' ) return 10;
		return 9;
	}

	if ( chip.info.groupe == GROUPE_SILVER ) return 1;
	if ( chip.info.groupe == GROUPE_WORKER ) return 0;
	if ( chip.info.groupe == GROUPE_BONUS_MAX ) return 23;
	if ( chip.info.groupe == GROUPE_BONUS_MIN ) return 24;
	if ( chip.info.groupe == GROUPE_SHIP ) return 11;
	if ( chip.info.groupe == GROUPE_ANIMAL ) return 12;
	if ( chip.info.groupe == GROUPE_CASTLE ) return 13;
	if ( chip.info.groupe == GROUPE_MINE ) return 14;

	if ( chip.info.groupe == GROUPE_KNOWLEGE ) return ( chip.info.variant + 22 );
	if ( chip.info.groupe == GROUPE_BUILDING ) return ( chip.info.variant - 26 );
}

function __locate(x, y) {
	var l = x + 20,
		t = y + 20,
		w = floatHint.width('px'),
		h = floatHint.height('px'),
		W = Plugin->canvas.width('px'),
		H = Plugin->canvas.height('px');

	if ( l + w > W ) l = W - w;
	if ( t + h > H ) t = H - h;

	floatHint.left(l + 'px');
	floatHint.top(t + 'px');
}
